;(function (f) {
  function p(a) {
    return !isNaN(a) && isFinite(a)
  }
  function q(a, c) {
    for (var b = 0, d = a.length; b < d; b++) if (a[b] === c) return b
    return -1
  }
  f.Octree = function (a) {
    a = a || {}
    a.tree = this
    this.nodeCount = 0
    this.INDEX_INSIDE_CROSS = -1
    this.INDEX_OUTSIDE_OFFSET = 2
    this.INDEX_OUTSIDE_POS_X = p(a.INDEX_OUTSIDE_POS_X)
      ? a.INDEX_OUTSIDE_POS_X
      : 0
    this.INDEX_OUTSIDE_NEG_X = p(a.INDEX_OUTSIDE_NEG_X)
      ? a.INDEX_OUTSIDE_NEG_X
      : 1
    this.INDEX_OUTSIDE_POS_Y = p(a.INDEX_OUTSIDE_POS_Y)
      ? a.INDEX_OUTSIDE_POS_Y
      : 2
    this.INDEX_OUTSIDE_NEG_Y = p(a.INDEX_OUTSIDE_NEG_Y)
      ? a.INDEX_OUTSIDE_NEG_Y
      : 3
    this.INDEX_OUTSIDE_POS_Z = p(a.INDEX_OUTSIDE_POS_Z)
      ? a.INDEX_OUTSIDE_POS_Z
      : 4
    this.INDEX_OUTSIDE_NEG_Z = p(a.INDEX_OUTSIDE_NEG_Z)
      ? a.INDEX_OUTSIDE_NEG_Z
      : 5
    this.INDEX_OUTSIDE_MAP = []
    this.INDEX_OUTSIDE_MAP[this.INDEX_OUTSIDE_POS_X] = {
      index: this.INDEX_OUTSIDE_POS_X,
      count: 0,
      x: 1,
      y: 0,
      z: 0,
    }
    this.INDEX_OUTSIDE_MAP[this.INDEX_OUTSIDE_NEG_X] = {
      index: this.INDEX_OUTSIDE_NEG_X,
      count: 0,
      x: -1,
      y: 0,
      z: 0,
    }
    this.INDEX_OUTSIDE_MAP[this.INDEX_OUTSIDE_POS_Y] = {
      index: this.INDEX_OUTSIDE_POS_Y,
      count: 0,
      x: 0,
      y: 1,
      z: 0,
    }
    this.INDEX_OUTSIDE_MAP[this.INDEX_OUTSIDE_NEG_Y] = {
      index: this.INDEX_OUTSIDE_NEG_Y,
      count: 0,
      x: 0,
      y: -1,
      z: 0,
    }
    this.INDEX_OUTSIDE_MAP[this.INDEX_OUTSIDE_POS_Z] = {
      index: this.INDEX_OUTSIDE_POS_Z,
      count: 0,
      x: 0,
      y: 0,
      z: 1,
    }
    this.INDEX_OUTSIDE_MAP[this.INDEX_OUTSIDE_NEG_Z] = {
      index: this.INDEX_OUTSIDE_NEG_Z,
      count: 0,
      x: 0,
      y: 0,
      z: -1,
    }
    this.FLAG_POS_X = 1 << (this.INDEX_OUTSIDE_POS_X + 1)
    this.FLAG_NEG_X = 1 << (this.INDEX_OUTSIDE_NEG_X + 1)
    this.FLAG_POS_Y = 1 << (this.INDEX_OUTSIDE_POS_Y + 1)
    this.FLAG_NEG_Y = 1 << (this.INDEX_OUTSIDE_NEG_Y + 1)
    this.FLAG_POS_Z = 1 << (this.INDEX_OUTSIDE_POS_Z + 1)
    this.FLAG_NEG_Z = 1 << (this.INDEX_OUTSIDE_NEG_Z + 1)
    this.utilVec31Search = new f._0x1()
    this.utilVec32Search = new f._0x1()
    if ((this.scene = a.scene))
      (this.visual_0x6 = new f.Box_0x6(1, 1, 1)),
        (this.visualMaterial = new f.naBasicMaterial({
          color: 3158064,
          wireframe: !0,
          wireframeLinewidth: 1,
        }))
    this.objects = []
    this.objectsMap = {}
    this.objectsData = []
    this.objectsDeferred = []
    this.depthMax = p(a.depthMax) ? a.depthMax : Infinity
    this.objectsThreshold = p(a.objectsThreshold) ? a.objectsThreshold : 8
    this.overlapPct = p(a.overlapPct) ? a.overlapPct : 0.15
    this.undeferred = a.undeferred || !1
    this.root = a.root instanceof f.OctreeNode ? a.root : new f.OctreeNode(a)
  }
  f.Octree.prototype = {
    update: function () {
      if (0 < this.objectsDeferred.length) {
        for (var a = 0, c = this.objectsDeferred.length; a < c; a++) {
          var b = this.objectsDeferred[a]
          this.addDeferred(b.object, b.options)
        }
        this.hideParentVirturna()
        this.objectsDeferred.length = 0
      }
    },
    add: function (a, c) {
      this.undeferred
        ? (this.updateObject(a), this.addDeferred(a, c))
        : this.objectsDeferred.push({ object: a, options: c })
    },
    hideParentVirturna: function (a) {
      var c = this
      null == a && (a = this.root)
      a.nodesIndices.forEach(function (b) {
        c.hideParentVirturna(a.nodesByIndex[b])
      })
    },
    getTreeArray: function (a, c) {
      var b = this
      null == c[a.depth] && (c[a.depth] = [])
      0 < a.objects.length && c[a.depth].push(a)
      a.nodesIndices.forEach(function (d) {
        b.getTreeArray(a.nodesByIndex[d], c)
      })
    },
    debugCameraByNode: function (a) {
      var c = [],
        b = []
      this.getTreeArray(this.root, c)
      c.forEach(function (c) {
        for (var d = !1, g = 0; g < c.length; g++) {
          for (var h = (c[g].tc = 0); h < c.length; h++)
            if (h != g) {
              var d = a.position.distanceTo(c[h].position),
                k = new f._0x1(
                  c[h].position.x,
                  c[h].position.y,
                  c[h].position.z
                )
              ;(d = c[g].intersectRay(
                a.position,
                k.sub(a.position).normalize(),
                d
              )) && c[g].tc++
            }
          3 < c[g].tc &&
            c[g].objects.forEach(function (a) {
              a.object.visible = !1
              b.push(a)
            })
          if (d) break
        }
      })
      console.log(b)
    },
    addDeferred: function (a, c) {
      var b, d, e
      a instanceof f.OctreeObjectData && (a = a.object)
      a.uuid || (a.uuid = f.Math.generateUUID())
      if (!this.objectsMap[a.uuid])
        if (
          (this.objects.push(a),
          (this.objectsMap[a.uuid] = a),
          c && ((b = c.useFaces), (d = c.useVertices)),
          !0 === d)
        )
          for (b = a.geometry, e = b.vertices, b = 0, d = e.length; b < d; b++)
            this.addObjectData(a, e[b])
        else if (!0 === b)
          for (b = a.geometry, e = b.faces, b = 0, d = e.length; b < d; b++)
            this.addObjectData(a, e[b])
        else this.addObjectData(a)
    },
    addObjectData: function (a, c) {
      var b = new f.OctreeObjectData(a, c)
      this.objectsData.push(b)
      this.root.addObject(b)
    },
    remove: function (a) {
      var c,
        b = a,
        d,
        e
      a instanceof f.OctreeObjectData && (a = a.object)
      if (this.objectsMap[a.uuid]) {
        if (
          ((this.objectsMap[a.uuid] = void 0),
          (d = q(this.objects, a)),
          -1 !== d)
        )
          for (
            this.objects.splice(d, 1),
              e = this.root.removeObject(b),
              a = 0,
              c = e.length;
            a < c;
            a++
          )
            (b = e[a]),
              (d = q(this.objectsData, b)),
              -1 !== d && this.objectsData.splice(d, 1)
      } else if (0 < this.objectsDeferred.length) {
        a: {
          b = this.objectsDeferred
          c = 0
          for (d = b.length; c < d; c++)
            if (b[c].object === a) {
              d = c
              break a
            }
          d = -1
        }
        ;-1 !== d && this.objectsDeferred.splice(d, 1)
      }
    },
    extend: function (a) {
      var c, b, d
      if (a instanceof f.Octree)
        for (b = a.objectsData, a = 0, c = b.length; a < c; a++)
          (d = b[a]),
            this.add(d, { useFaces: d.faces, useVertices: d.vertices })
    },
    rebuild: function () {
      var a,
        c,
        b,
        d,
        e,
        g = []
      a = 0
      for (c = this.objectsData.length; a < c; a++)
        (d = this.objectsData[a]),
          (b = d.node),
          d.update(),
          b instanceof f.OctreeNode &&
            !d.positionLast.equals(d.position) &&
            ((e = d.indexOctant),
            (b = b.getOctantIndex(d)),
            b !== e && g.push(d))
      a = 0
      for (c = g.length; a < c; a++)
        (d = g[a]), d.node.removeObject(d), this.root.addObject(d)
    },
    updateObject: function (a) {
      var c,
        b = [a],
        d,
        e
      for (d = a.parent; d; ) b.push(d), (d = d.parent)
      a = 0
      for (c = b.length; a < c; a++)
        (d = b[a]), !0 === d.matrixWorldNeedsUpdate && (e = d)
      'undefined' !== typeof e && e.updateMatrixWorld()
    },
    search: function (a, c, b, d) {
      var e, g, h, k, l
      k = [].concat(this.root.objects)
      0 < c || (c = Number.MAX_VALUE)
      d instanceof f._0x1 &&
        ((d = this.utilVec31Search.copy(d).normalize()),
        (l = this.utilVec32Search.set(1, 1, 1).divide(d)))
      e = 0
      for (g = this.root.nodesIndices.length; e < g; e++)
        (h = this.root.nodesByIndex[this.root.nodesIndices[e]]),
          (k = h.search(a, c, k, d, l))
      if (!0 === b)
        for (b = [], d = [], e = 0, g = k.length; e < g; e++)
          (a = k[e]),
            (c = a.object),
            (h = q(d, c)),
            -1 === h
              ? ((h = { object: c, faces: [], vertices: [] }),
                b.push(h),
                d.push(c))
              : (h = b[h]),
            a.faces
              ? h.faces.push(a.faces)
              : a.vertices && h.vertices.push(a.vertices)
      else b = k
      return b
    },
    searchna: function (a, c, b, d) {
      a = this.search(a, c, b, d)
      c = []
      for (b = 0; b < a.length; b++) a[b].object.visible && c.push(a[b].object)
      return c
    },
    setRoot: function (a) {
      a instanceof f.OctreeNode &&
        ((this.root = a), this.root.updateProperties())
    },
    getDepthEnd: function () {
      return this.root.getDepthEnd()
    },
    getNodeCountEnd: function () {
      return this.root.getNodeCountEnd()
    },
    getObjectCountEnd: function () {
      return this.root.getObjectCountEnd()
    },
    toConsole: function () {
      this.root.toConsole()
    },
  }
  f.OctreeObjectData = function (a, c) {
    this.object = a
    c instanceof f._0x4
      ? ((this.faces = c),
        (this.face3 = !0),
        (this.utilVec31FaceBounds = new f._0x1()))
      : c instanceof f._0x1 && (this.vertices = c)
    this.radius = 0
    this.position = new f._0x1()
    this.object instanceof f.Object3D && this.update()
    this.positionLast = this.position.clone()
  }
  f.OctreeObjectData.prototype = {
    update: function () {
      this.face3
        ? ((this.radius = this.get_0x4BoundingRadius(this.object, this.faces)),
          this.position
            .copy(this.faces.centroid)
            .applyMatrix4(this.object.matrixWorld))
        : this.vertices
        ? ((this.radius = this.object.material.size || 1),
          this.position
            .copy(this.vertices)
            .applyMatrix4(this.object.matrixWorld))
        : this.object.geometry
        ? (null === this.object.geometry.boundingSphere &&
            this.object.geometry.computeBoundingSphere(),
          (this.radius = this.object.geometry.boundingSphere.radius),
          this.position
            .copy(this.object.geometry.boundingSphere.center)
            .applyMatrix4(this.object.matrixWorld))
        : ((this.radius = this.object.boundRadius),
          this.position.setFromMatrixPosition(this.object.matrixWorld))
      this.radius *= Math.max(
        this.object.scale.x,
        this.object.scale.y,
        this.object.scale.z
      )
    },
    get_0x4BoundingRadius: function (a, c) {
      void 0 === c.centroid && (c.centroid = new f._0x1())
      var b = (a.geometry || a).vertices,
        d = c.centroid,
        e = b[c.a],
        g = b[c.b],
        b = b[c.c],
        h = this.utilVec31FaceBounds
      d.addVectors(e, g).add(b).divideScalar(3)
      return Math.max(
        h.subVectors(d, e).length(),
        h.subVectors(d, g).length(),
        h.subVectors(d, b).length()
      )
    },
  }
  f.OctreeNode = function (a) {
    this.utilVec31Branch = new f._0x1()
    this.utilVec31Expand = new f._0x1()
    this.utilVec31Ray = new f._0x1()
    a = a || {}
    a.tree instanceof f.Octree
      ? (this.tree = a.tree)
      : !0 !== a.parent instanceof f.OctreeNode &&
        ((a.root = this), (this.tree = new f.Octree(a)))
    this.id = this.tree.nodeCount++
    this.position = a.position instanceof f._0x1 ? a.position : new f._0x1()
    this.radius = 0 < a.radius ? a.radius : 1
    this.indexOctant = a.indexOctant
    this.depth = 0
    this.reset()
    this.setParent(a.parent)
    this.overlap = this.radius * this.tree.overlapPct
    this.radiusOverlap = this.radius + this.overlap
    this.left = this.position.x - this.radiusOverlap
    this.right = this.position.x + this.radiusOverlap
    this.bottom = this.position.y - this.radiusOverlap
    this.top = this.position.y + this.radiusOverlap
    this.back = this.position.z - this.radiusOverlap
    this.front = this.position.z + this.radiusOverlap
    this.tree.scene &&
      ((this.visual = new f.na(this.tree.visual_0x6, this.tree.visualMaterial)),
      this.visual.scale.set(
        2 * this.radiusOverlap,
        2 * this.radiusOverlap,
        2 * this.radiusOverlap
      ),
      this.visual.position.copy(this.position),
      this.tree.scene.add(this.visual))
  }
  f.OctreeNode.prototype = {
    setParent: function (a) {
      a !== this &&
        this.parent !== a &&
        ((this.parent = a), this.updateProperties())
    },
    updateProperties: function () {
      var a, c
      this.parent instanceof f.OctreeNode
        ? ((this.tree = this.parent.tree), (this.depth = this.parent.depth + 1))
        : (this.depth = 0)
      a = 0
      for (c = this.nodesIndices.length; a < c; a++)
        this.nodesByIndex[this.nodesIndices[a]].updateProperties()
    },
    reset: function (a, c) {
      var b,
        d,
        e,
        g = this.nodesIndices || [],
        h = this.nodesByIndex
      this.objects = []
      this.nodesIndices = []
      this.nodesByIndex = {}
      b = 0
      for (d = g.length; b < d; b++)
        (e = h[g[b]]), e.setParent(void 0), !0 === a && e.reset(a, c)
      !0 === c &&
        this.visual &&
        this.visual.parent &&
        this.visual.parent.remove(this.visual)
    },
    addNode: function (a, c) {
      a.indexOctant = c
      ;-1 === q(this.nodesIndices, c) && this.nodesIndices.push(c)
      this.nodesByIndex[c] = a
      a.parent !== this && a.setParent(this)
    },
    removeNode: function (a) {
      var c, b
      c = q(this.nodesIndices, a)
      this.nodesIndices.splice(c, 1)
      b = b || this.nodesByIndex[a]
      delete this.nodesByIndex[a]
      b.parent === this && b.setParent(void 0)
    },
    addObject: function (a) {
      var c
      c = this.getOctantIndex(a)
      ;-1 < c && 0 < this.nodesIndices.length
        ? ((c = this.branch(c)), c.addObject(a))
        : -1 > c && this.parent instanceof f.OctreeNode
        ? this.parent.addObject(a)
        : ((c = q(this.objects, a)),
          -1 === c && this.objects.push(a),
          (a.node = this),
          this.checkGrow())
    },
    addObjectWithoutCheck: function (a) {
      var c, b, d
      c = 0
      for (b = a.length; c < b; c++)
        (d = a[c]), this.objects.push(d), (d.node = this)
    },
    removeObject: function (a) {
      var c, b, d
      d = this.removeObjectRecursive(a, {
        searchComplete: !1,
        nodesRemovedFrom: [],
        objectsDataRemoved: [],
      })
      b = d.nodesRemovedFrom
      if (0 < b.length) for (a = 0, c = b.length; a < c; a++) b[a].shrink()
      return d.objectsDataRemoved
    },
    removeObjectRecursive: function (a, c) {
      var b, d, e
      if (a instanceof f.OctreeObjectData)
        (b = q(this.objects, a)),
          -1 !== b &&
            (this.objects.splice(b, 1),
            (a.node = void 0),
            c.objectsDataRemoved.push(a),
            (c.searchComplete = d = !0))
      else
        for (b = this.objects.length - 1; 0 <= b; b--)
          if (
            ((e = this.objects[b]),
            e.object === a &&
              (this.objects.splice(b, 1),
              (e.node = void 0),
              c.objectsDataRemoved.push(e),
              (d = !0),
              !e.faces && !e.vertices))
          ) {
            c.searchComplete = !0
            break
          }
      !0 === d && c.nodesRemovedFrom.push(this)
      if (!0 !== c.searchComplete)
        for (
          b = 0, d = this.nodesIndices.length;
          b < d &&
          ((e = this.nodesByIndex[this.nodesIndices[b]]),
          (c = e.removeObjectRecursive(a, c)),
          !0 !== c.searchComplete);
          b++
        );
      return c
    },
    checkGrow: function () {
      this.objects.length > this.tree.objectsThreshold &&
        0 < this.tree.objectsThreshold &&
        this.grow()
    },
    grow: function () {
      var a,
        c,
        b = [],
        d = [],
        e = [],
        g = [],
        h = [],
        f,
        l
      f = 0
      for (l = this.objects.length; f < l; f++)
        (c = this.objects[f]),
          (a = this.getOctantIndex(c)),
          -1 < a
            ? (e.push(c), g.push(a))
            : -1 > a
            ? (b.push(c), d.push(a))
            : h.push(c)
      0 < e.length && (h = h.concat(this.split(e, g)))
      0 < b.length && (h = h.concat(this.expand(b, d)))
      this.objects = h
      this.checkMerge()
    },
    split: function (a, c) {
      var b, d, e, g, h
      if (this.depth < this.tree.depthMax) {
        a = a || this.objects
        c = c || []
        h = []
        b = 0
        for (d = a.length; b < d; b++)
          (g = a[b]),
            (e = c[b]),
            -1 < e ? ((e = this.branch(e)), e.addObject(g)) : h.push(g)
        a === this.objects && (this.objects = h)
      } else h = this.objects
      return h
    },
    branch: function (a) {
      var c, b
      this.nodesByIndex[a] instanceof f.OctreeNode
        ? (c = this.nodesByIndex[a])
        : ((c = 0.5 * this.radiusOverlap),
          (b = c * this.tree.overlapPct),
          (b = c - b),
          (b = this.utilVec31Branch.set(
            a & 1 ? b : -b,
            a & 2 ? b : -b,
            a & 4 ? b : -b
          )),
          (b = new f._0x1().addVectors(this.position, b)),
          (c = new f.OctreeNode({
            tree: this.tree,
            parent: this,
            position: b,
            radius: c,
            indexOctant: a,
          })),
          this.addNode(c, a))
      return c
    },
    expand: function (a, c) {
      var b,
        d,
        e,
        g,
        h,
        k,
        l = this.tree.INDEX_OUTSIDE_MAP,
        n,
        m,
        p,
        q,
        r = this.utilVec31Expand
      if (this.tree.root.getDepthEnd() < this.tree.depthMax) {
        a = a || this.objects
        c = c || []
        g = []
        h = []
        b = 0
        for (d = l.length; b < d; b++) l[b].count = 0
        b = 0
        for (d = a.length; b < d; b++)
          (e = a[b]),
            (k = c[b]),
            -1 > k
              ? ((k = -k - this.tree.INDEX_OUTSIDE_OFFSET),
                k & this.tree.FLAG_POS_X
                  ? l[this.tree.INDEX_OUTSIDE_POS_X].count++
                  : k & this.tree.FLAG_NEG_X &&
                    l[this.tree.INDEX_OUTSIDE_NEG_X].count++,
                k & this.tree.FLAG_POS_Y
                  ? l[this.tree.INDEX_OUTSIDE_POS_Y].count++
                  : k & this.tree.FLAG_NEG_Y &&
                    l[this.tree.INDEX_OUTSIDE_NEG_Y].count++,
                k & this.tree.FLAG_POS_Z
                  ? l[this.tree.INDEX_OUTSIDE_POS_Z].count++
                  : k & this.tree.FLAG_NEG_Z &&
                    l[this.tree.INDEX_OUTSIDE_NEG_Z].count++,
                h.push(e))
              : g.push(e)
        if (0 < h.length)
          for (
            n = l.slice(0),
              n.sort(function (a, b) {
                return b.count - a.count
              }),
              k = n[0],
              d = k.index | 1,
              l = n[1],
              m = n[2],
              b = (l.index | 1) !== d ? l : m,
              e = b.index | 1,
              l = n[2],
              m = n[3],
              n = n[4],
              p = l.index | 1,
              q = m.index | 1,
              l = p !== d && p !== e ? l : q !== d && q !== e ? m : n,
              d = k.x + b.x + l.x,
              e = k.y + b.y + l.y,
              b = k.z + b.z + l.z,
              k = this.getOctantIndexFromPosition(d, e, b),
              b = this.getOctantIndexFromPosition(-d, -e, -b),
              e = this.overlap,
              l = this.radius,
              d =
                0 < this.tree.overlapPct
                  ? e /
                    (0.5 * this.tree.overlapPct * (1 + this.tree.overlapPct))
                  : 2 * l,
              m = d * this.tree.overlapPct,
              e = d + m - (l + e),
              r.set(k & 1 ? e : -e, k & 2 ? e : -e, k & 4 ? e : -e),
              r = new f._0x1().addVectors(this.position, r),
              r = new f.OctreeNode({ tree: this.tree, position: r, radius: d }),
              r.addNode(this, b),
              this.tree.setRoot(r),
              b = 0,
              d = h.length;
            b < d;
            b++
          )
            this.tree.root.addObject(h[b])
        a === this.objects && (this.objects = g)
      } else g = a
      return g
    },
    shrink: function () {
      this.checkMerge()
      this.tree.root.checkContract()
    },
    checkMerge: function () {
      for (
        var a = this, c;
        a.parent instanceof f.OctreeNode &&
        a.getObjectCountEnd() < this.tree.objectsThreshold;

      )
        (c = a), (a = a.parent)
      a !== this && a.merge(c)
    },
    merge: function (a) {
      var c, b, d
      a = a
        ? ('[object Array]' === Object.prototype.toString.call(a)) !== !0
          ? [a]
          : a
        : []
      c = 0
      for (b = a.length; c < b; c++)
        (d = a[c]),
          this.addObjectWithoutCheck(d.getObjectsEnd()),
          d.reset(!0, !0),
          this.removeNode(d.indexOctant, d)
      this.checkMerge()
    },
    checkContract: function () {
      var a, c, b, d, e, g, h
      if (0 < this.nodesIndices.length) {
        g = 0
        h = this.objects.length
        a = 0
        for (c = this.nodesIndices.length; a < c; a++)
          if (
            ((b = this.nodesByIndex[this.nodesIndices[a]]),
            (d = b.getObjectCountEnd()),
            (h += d),
            !1 === e instanceof f.OctreeNode || d > g)
          )
            (e = b), (g = d)
        h - g < this.tree.objectsThreshold &&
          e instanceof f.OctreeNode &&
          this.contract(e)
      }
    },
    contract: function (a) {
      var c, b, d
      c = 0
      for (b = this.nodesIndices.length; c < b; c++)
        (d = this.nodesByIndex[this.nodesIndices[c]]),
          d !== a &&
            (a.addObjectWithoutCheck(d.getObjectsEnd()), d.reset(!0, !0))
      a.addObjectWithoutCheck(this.objects)
      this.reset(!1, !0)
      this.tree.setRoot(a)
      a.checkContract()
    },
    getOctantIndex: function (a) {
      var c,
        b,
        d = this.position,
        e = this.radiusOverlap,
        g = this.overlap,
        h,
        k,
        l,
        n,
        m = 0
      a instanceof f.OctreeObjectData
        ? ((b = a.radius), (c = a.position), a.positionLast.copy(c))
        : a instanceof f.OctreeNode && ((c = a.position), (b = 0))
      h = c.x - d.x
      k = c.y - d.y
      c = c.z - d.z
      d = Math.abs(h)
      l = Math.abs(k)
      n = Math.abs(c)
      if (Math.max(d, l, n) + b > e)
        return (
          d + b > e &&
            (m ^= 0 < h ? this.tree.FLAG_POS_X : this.tree.FLAG_NEG_X),
          l + b > e &&
            (m ^= 0 < k ? this.tree.FLAG_POS_Y : this.tree.FLAG_NEG_Y),
          n + b > e &&
            (m ^= 0 < c ? this.tree.FLAG_POS_Z : this.tree.FLAG_NEG_Z),
          (a.indexOctant = -m - this.tree.INDEX_OUTSIDE_OFFSET),
          a.indexOctant
        )
      if (h - b > -g) m |= 1
      else if (!(h + b < g))
        return (a.indexOctant = this.tree.INDEX_INSIDE_CROSS), a.indexOctant
      if (k - b > -g) m |= 2
      else if (!(k + b < g))
        return (a.indexOctant = this.tree.INDEX_INSIDE_CROSS), a.indexOctant
      if (c - b > -g) m |= 4
      else if (!(c + b < g))
        return (a.indexOctant = this.tree.INDEX_INSIDE_CROSS), a.indexOctant
      a.indexOctant = m
      return a.indexOctant
    },
    getOctantIndexFromPosition: function (a, c, b) {
      var d = 0
      0 < a && (d |= 1)
      0 < c && (d |= 2)
      0 < b && (d |= 4)
      return d
    },
    search: function (a, c, b, d, e) {
      var g, h
      if (
        !0 === (d ? this.intersectRay(a, d, c, e) : this.intersectSphere(a, c))
      )
        for (
          b = b.concat(this.objects), e = 0, g = this.nodesIndices.length;
          e < g;
          e++
        )
          (h = this.nodesByIndex[this.nodesIndices[e]]),
            (b = h.search(a, c, b, d))
      return b
    },
    intersectSphere: function (a, c) {
      var b = c * c,
        d = a.x,
        e = a.y,
        g = a.z
      d < this.left
        ? (b -= Math.pow(d - this.left, 2))
        : d > this.right && (b -= Math.pow(d - this.right, 2))
      e < this.bottom
        ? (b -= Math.pow(e - this.bottom, 2))
        : e > this.top && (b -= Math.pow(e - this.top, 2))
      g < this.back
        ? (b -= Math.pow(g - this.back, 2))
        : g > this.front && (b -= Math.pow(g - this.front, 2))
      return 0 <= b
    },
    intersectRay: function (a, c, b, d) {
      'undefined' === typeof d && (d = this.utilVec31Ray.set(1, 1, 1).divide(c))
      c = (this.left - a.x) * d.x
      var e = (this.right - a.x) * d.x,
        g = (this.bottom - a.y) * d.y,
        h = (this.top - a.y) * d.y,
        f = (this.back - a.z) * d.z
      d = (this.front - a.z) * d.z
      a = Math.min(Math.min(Math.max(c, e), Math.max(g, h)), Math.max(f, d))
      if (0 > a) return !1
      c = Math.max(Math.max(Math.min(c, e), Math.min(g, h)), Math.min(f, d))
      return c > a || c > b ? !1 : !0
    },
    getDepthEnd: function (a) {
      var c, b, d
      if (0 < this.nodesIndices.length)
        for (c = 0, b = this.nodesIndices.length; c < b; c++)
          (d = this.nodesByIndex[this.nodesIndices[c]]), (a = d.getDepthEnd(a))
      else a = !a || this.depth > a ? this.depth : a
      return a
    },
    getNodeCountEnd: function () {
      return this.tree.root.getNodeCountRecursive() + 1
    },
    getNodeCountRecursive: function () {
      var a,
        c,
        b = this.nodesIndices.length
      a = 0
      for (c = this.nodesIndices.length; a < c; a++)
        b += this.nodesByIndex[this.nodesIndices[a]].getNodeCountRecursive()
      return b
    },
    getObjectsEnd: function (a) {
      var c, b, d
      a = (a || []).concat(this.objects)
      c = 0
      for (b = this.nodesIndices.length; c < b; c++)
        (d = this.nodesByIndex[this.nodesIndices[c]]), (a = d.getObjectsEnd(a))
      return a
    },
    getObjectCountEnd: function () {
      var a,
        c,
        b = this.objects.length
      a = 0
      for (c = this.nodesIndices.length; a < c; a++)
        b += this.nodesByIndex[this.nodesIndices[a]].getObjectCountEnd()
      return b
    },
    getObjectCountStart: function () {
      for (
        var a = this.objects.length, c = this.parent;
        c instanceof f.OctreeNode;

      )
        (a += c.objects.length), (c = c.parent)
      return a
    },
    toConsole: function (a) {
      var c, b, d
      a = 'string' === typeof a ? a : '   '
      console.log(
        this.parent ? a + ' octree NODE \x3e ' : ' octree ROOT \x3e ',
        this,
        ' // id: ',
        this.id,
        ' // indexOctant: ',
        this.indexOctant,
        ' // position: ',
        this.position.x,
        this.position.y,
        this.position.z,
        ' // radius: ',
        this.radius,
        ' // depth: ',
        this.depth
      )
      console.log(
        this.parent ? a + ' ' : ' ',
        '+ objects ( ',
        this.objects.length,
        ' ) ',
        this.objects
      )
      console.log(
        this.parent ? a + ' ' : ' ',
        '+ children ( ',
        this.nodesIndices.length,
        ' )',
        this.nodesIndices,
        this.nodesByIndex
      )
      c = 0
      for (b = this.nodesIndices.length; c < b; c++)
        (d = this.nodesByIndex[this.nodesIndices[c]]), d.toConsole(a + '   ')
    },
  }
  f.rct.prototype.intersectOctreeObject = function (a, c) {
    var b, d, e
    a.object instanceof f.Object3D
      ? ((b = a),
        (a = b.object),
        (e = b.faces),
        (d = a.geometry.faces),
        0 < e.length && (a.geometry.faces = e),
        (b = this.intersectObject(a, c)),
        0 < e.length && (a.geometry.faces = d))
      : (b = this.intersectObject(a, c))
    return b
  }
  f.rct.prototype.intersectOctreeObjects = function (a, c) {
    var b,
      d,
      e = []
    b = 0
    for (d = a.length; b < d; b++)
      e = e.concat(this.intersectOctreeObject(a[b], c))
    return e
  }
})(THREE)
